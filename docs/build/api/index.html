<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · GraphLab.jl</title><meta name="title" content="API Reference · GraphLab.jl"/><meta property="og:title" content="API Reference · GraphLab.jl"/><meta property="twitter:title" content="API Reference · GraphLab.jl"/><meta name="description" content="Documentation for GraphLab.jl."/><meta property="og:description" content="Documentation for GraphLab.jl."/><meta property="twitter:description" content="Documentation for GraphLab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GraphLab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphLab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage Guide</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li><li><a class="tocitem" href="../dev_api/">Developers API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lechekhabm/GraphLab.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This section lists the public functions and types exported by <code>GraphLab.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.KdNode" href="#GraphLab.KdNode"><code>GraphLab.KdNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KdNode</code></pre><p>A node in a 2D kd-tree data structure, representing a spatial region and its recursive subdivision.</p><p>Each node contains bounding box coordinates, optional _splitting information, and links to child nodes. The node can also store associated data points and optional entry/exit traversal symbols for space-filling curve traversal.</p><p><strong>Fields</strong></p><ul><li><code>bbox::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}</code>: Bounding box as <code>(min_coords, max_coords)</code>.</li><li><code>_splitdim::Union{Int, Nothing}</code>: _splitting dimension (1 for x-axis, 2 for y-axis), or <code>nothing</code> for leaf.</li><li><code>_splitval::Union{Float64, Nothing}</code>: Coordinate value of the _splitting plane, or <code>nothing</code> for leaf.</li><li><code>left::Union{KdNode, Nothing}</code>: Left child node (subtree with coordinates ≤ <code>_splitval</code>), or <code>nothing</code>.</li><li><code>right::Union{KdNode, Nothing}</code>: Right child node (subtree with coordinates &gt; <code>_splitval</code>), or <code>nothing</code>.</li><li><code>is_leaf::Bool</code>: Whether the node is a leaf.</li><li><code>is_root::Bool</code>: Whether the node is the root of the tree.</li><li><code>data::Matrix{Float64}</code>: Data points contained in this node.</li><li><code>entry::Union{Symbol, Nothing}</code>: Optional entry symbol for space-filling curve traversal.</li><li><code>exit::Union{Symbol, Nothing}</code>: Optional exit symbol for space-filling curve traversal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._append_gilbert!-Tuple{Vector{CartesianIndex{2}}, AbstractMatrix}" href="#GraphLab._append_gilbert!-Tuple{Vector{CartesianIndex{2}}, AbstractMatrix}"><code>GraphLab._append_gilbert!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_append_gilbert!(path, grid::AbstractMatrix)</code></pre><p>Recursively traverse the given matrix <code>grid</code> using a generalized Gilbert curve pattern. Appends the <code>CartesianIndex</code> entries to <code>path</code> in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._bbox_center-Tuple{Any}" href="#GraphLab._bbox_center-Tuple{Any}"><code>GraphLab._bbox_center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_bbox_center(bbox)</code></pre><p>Compute the center point of a bounding box.</p><p><strong>Arguments</strong></p><ul><li><code>bbox</code>: A tuple <code>((xmin, ymin), (xmax, ymax))</code> representing the bounding box corners.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(xcenter, ycenter)</code> representing the center coordinates of the bounding box.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>bbox</em>center(((0.0, 0.0), (2.0, 4.0))) (1.0, 2.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._bounding_box-Tuple{Matrix{Float64}}" href="#GraphLab._bounding_box-Tuple{Matrix{Float64}}"><code>GraphLab._bounding_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_bounding_box(coords::Matrix{Float64})</code></pre><p>Compute the axis-aligned bounding box for a set of 2D points.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix{Float64}</code>: A matrix of size <code>n × 2</code>, where each row represents a 2D point <code>(x, y)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>((xmin, ymin), (xmax, ymax))</code> representing the lower-left and upper-right corners of the bounding box.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>bounding</em>box([1.0 2.0; 3.0 4.0; -1.0 5.0]) ((-1.0, 2.0), (3.0, 5.0))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._build_tree" href="#GraphLab._build_tree"><code>GraphLab._build_tree</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_build_tree(coords::Matrix{Float64}, is_root::Bool=true)</code></pre><p>Recursively build a 2D kd-tree from a set of points. Leaf nodes contain the data points inside their region.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix{Float64}</code>: A matrix of size <code>n × 2</code>, where each row is a 2D point <code>(x, y)</code>.</li><li><code>is_root::Bool=true</code>: Whether this node is the root of the tree (automatically set during recursion).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>KdNode</code> representing the root of the kd-tree.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; tree = <em>build</em>tree([1.0 2.0; 3.0 4.0; 0.0 5.0]) KdNode(...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._centerpoint-Tuple{Matrix{Float64}, Int64}" href="#GraphLab._centerpoint-Tuple{Matrix{Float64}, Int64}"><code>GraphLab._centerpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Approximate _centerpoint by coordinate-wise median of a random sample.</p><p>Arguments:</p><ul><li>X::Matrix{Float64}: n × d data matrix</li><li>sample_size::Int: number of random rows to sample</li></ul><p>Returns:</p><ul><li>center::Vector{Float64}: estimated _centerpoint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._conmap-Tuple{Vector{Float64}, Matrix{Float64}}" href="#GraphLab._conmap-Tuple{Vector{Float64}, Matrix{Float64}}"><code>GraphLab._conmap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Conformal map that moves <code>center</code> to the origin on the unit sphere.</p><p>Arguments:</p><ul><li>center::Vector{Float64}: _centerpoint on the sphere (length d+1)</li><li>X::Matrix{Float64}: n × (d+1) matrix of lifted points</li></ul><p>Returns:</p><ul><li>Y::Matrix{Float64}: transformed points (same size as X)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_alignment-Tuple{Symbol, Int64}" href="#GraphLab._get_alignment-Tuple{Symbol, Int64}"><code>GraphLab._get_alignment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_alignment(entry::Symbol, _splitdim::Int)</code></pre><p>Determine the alignment of an entry direction relative to the _splitting dimension.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Symbol</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>_splitdim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li></ul><p><strong>Returns</strong></p><ul><li><code>:parallel</code> if entry edge direction is parallel to the _splitting dimension.</li><li><code>:perpendicular</code> otherwise.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>get</em>alignment(:L, 1) :parallel julia&gt; <em>get</em>alignment(:T, 1) :perpendicular</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_child-Tuple{GraphLab.KdNode, Symbol}" href="#GraphLab._get_child-Tuple{GraphLab.KdNode, Symbol}"><code>GraphLab._get_child</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_child(node::KdNode, side::Symbol)</code></pre><p>Return the child node of a <code>KdNode</code> corresponding to the specified side.</p><p>This function retrieves either the left or right child node depending on the side and the _splitting dimension.</p><p><strong>Arguments</strong></p><ul><li><code>node::KdNode</code>: The kd-tree node.</li><li><code>side::Symbol</code>: Side indicator (<code>:left</code>, <code>:right</code>, <code>:bottom</code>, or <code>:top</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The child <code>KdNode</code> corresponding to the requested side.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>get</em>child(node, :left) KdNode(...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_child_entry_exit-Tuple{Symbol, Symbol, Int64, Symbol}" href="#GraphLab._get_child_entry_exit-Tuple{Symbol, Symbol, Int64, Symbol}"><code>GraphLab._get_child_entry_exit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_child_entry_exit(parent_entry::Symbol, parent_exit::Symbol, _splitdim::Int, side::Symbol)</code></pre><p>Compute the entry and exit directions for a child node in a kd-tree traversal.</p><p>Given the parent node’s entry and exit directions, the _splitting dimension, and the side being traversed, this function determines the entry and exit directions for the child node according to space-filling curve traversal rules (using <code>:cis</code> and <code>:tran</code> order types and <code>:parallel</code> / <code>:perpendicular</code> alignment).</p><p><strong>Arguments</strong></p><ul><li><code>parent_entry::Symbol</code>: Entry direction at the parent node (<code>:L</code>, <code>:R</code>, <code>:T</code>, <code>:B</code>).</li><li><code>parent_exit::Symbol</code>: Exit direction at the parent node (<code>:L</code>, <code>:R</code>, <code>:T</code>, <code>:B</code>).</li><li><code>_splitdim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li><li><code>side::Symbol</code>: Side of the child being traversed (<code>:left</code>, <code>:right</code>, <code>:top</code>, <code>:bottom</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(child_entry, child_exit)</code> indicating the entry and exit directions for the child node.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>get</em>child<em>entry</em>exit(:L, :R, 1, :left) (:L, :R)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_maximum_matching-Tuple{Graphs.SimpleGraphs.SimpleGraph}" href="#GraphLab._get_maximum_matching-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><code>GraphLab._get_maximum_matching</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_maximum_matching(g::Graph)</code></pre><p>Computes a maximum weight matching of the graph <code>g</code> using a silent CBC solver.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The input graph.</li></ul><p><strong>Returns</strong></p><ul><li><code>match</code>: The matching object containing mate assignments and total weight.</li></ul><p><strong>Notes</strong></p><ul><li>Assumes unit weights unless otherwise specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._get_partition-Tuple{AbstractVector, Int64}" href="#GraphLab._get_partition-Tuple{AbstractVector, Int64}"><code>GraphLab._get_partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_partition(v::AbstractVector, k::Int)</code></pre><p>Create a partition indicator vector by dividing indices into <code>k</code> contiguous groups.</p><p>This function assigns partition labels <code>1</code> to <code>k</code> to the indices in <code>v</code>, distributing them evenly into <code>k</code> partitions based on their position in <code>v</code>. Each value in <code>v</code> is assumed to be a node ID (1-based indexing), and the result maps each node ID to its partition.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector</code>: A vector of node IDs to partition.</li><li><code>k::Int</code>: The number of partitions.</li></ul><p><strong>Returns</strong></p><ul><li>A vector <code>part</code> of length <code>maximum(v)</code> where <code>part[id]</code> is the partition label (1 to <code>k</code>) assigned to node <code>id</code>.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>get</em>partition([1, 2, 3, 4, 5, 6], 2) [1, 1, 1, 2, 2, 2]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._gilbert_indices-Tuple{Tuple{Int64, Int64}}" href="#GraphLab._gilbert_indices-Tuple{Tuple{Int64, Int64}}"><code>GraphLab._gilbert_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_gilbert_indices(grid_dims::Tuple{Int, Int}; maj_axis=grid_dims[1] ≥ grid_dims[2] ? 1 : 2)</code></pre><p>Generate a list of <code>CartesianIndex{2}</code> representing a generalized space-filling traversal of a grid with dimensions <code>grid_dims</code>, using a Gilbert-like curve. Traversal will favor rows (X axis) if <code>maj_axis == 1</code>, or columns (Y axis) if <code>maj_axis == 2</code>.</p><p><strong>Arguments</strong></p><ul><li><code>grid_dims::Tuple{Int, Int}</code>: a tuple <code>(rows, cols)</code> specifying grid size.</li><li><code>maj_axis</code>: optional; either <code>1</code> (row-major preference) or <code>2</code> (column-major preference).<ul><li>The curve will traverse more linearly along the <code>maj_axis</code>.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector{CartesianIndex{2}}</code> representing the traversal path.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; order = _gilbert_indices((4, 5))
julia&gt; println(order)
[CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(2, 2), ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._gilbert_order-Tuple{AbstractMatrix}" href="#GraphLab._gilbert_order-Tuple{AbstractMatrix}"><code>GraphLab._gilbert_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_gilbert_order(grid_indices::AbstractMatrix; maj_axis=rows ≥ cols ? 1 : 2)</code></pre><p>Return a list of <code>CartesianIndex</code> values from a grid, traversed recursively using Gilbert curve logic. When <code>maj_axis == 2</code>, the grid is transposed to preserve logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._morton_index-Tuple{Int64, Int64}" href="#GraphLab._morton_index-Tuple{Int64, Int64}"><code>GraphLab._morton_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_morton_index(x::Int, y::Int)</code></pre><p>Interleave the bits of x and y to produce a Morton code (Z-order curve).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._morton_indices-Tuple{Tuple{Int64, Int64}}" href="#GraphLab._morton_indices-Tuple{Tuple{Int64, Int64}}"><code>GraphLab._morton_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_morton_indices(grid_dims::Tuple{Int, Int})</code></pre><p>Return a list of <code>CartesianIndex{2}</code> grid coordinates ordered by 2D Morton (Z-order) curve.</p><p><strong>Arguments</strong></p><ul><li><code>grid_dims::Tuple{Int, Int}</code>: the number of rows and columns of the grid, e.g. <code>(64, 64)</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>CartesianIndex{2}</code> objects representing the traversal order.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; order = _morton_indices((4, 4))
julia&gt; println(order)
[CartesianIndex(1, 1), CartesianIndex(1, 2), CartesianIndex(2, 1), CartesianIndex(2, 2), ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}" href="#GraphLab._nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}"><code>GraphLab._nested_dissection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_nested_dissection(A::SparseMatrixCSC, method::Function; coords=nothing, minsep, verbose)</code></pre><p>Recursively computes a nested dissection ordering of a sparse matrix, handling disconnected components separately.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: The adjacency matrix of the graph to partition.</li><li><code>method::Function</code>: Function used to compute separators.</li><li><code>coords::Union{Matrix, Nothing}</code>: Optional node coordinates if the separator method needs them.</li><li><code>minsep::Int</code>: Minimum number of nodes to stop recursion.</li><li><code>verbose::Bool</code>: Whether to visualize partitions and wait for user input during recursion.</li></ul><p><strong>Returns</strong></p><ul><li><code>perm::Vector{Int}</code>: The final permutation vector.</li></ul><p><strong>Notes</strong></p><ul><li>Uses approximate minimum degree ordering for small components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._opposite_dir-Tuple{Symbol}" href="#GraphLab._opposite_dir-Tuple{Symbol}"><code>GraphLab._opposite_dir</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_opposite_dir(dir::Symbol)::Symbol</code></pre><p>Return the opposite direction symbol.</p><p><strong>Arguments</strong></p><ul><li><code>dir::Symbol</code>: Direction symbol (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The opposite direction symbol.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>opposite</em>dir(:L) :R julia&gt; <em>opposite</em>dir(:T) :B</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._order_type-Tuple{Symbol, Symbol}" href="#GraphLab._order_type-Tuple{Symbol, Symbol}"><code>GraphLab._order_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_order_type(entry::Symbol, exit::Symbol)</code></pre><p>Determine the traversal type based on entry and exit directions.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Symbol</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>exit::Symbol</code>: Exit direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>:tran</code> if entry and exit are opposite directions.</li><li><code>:cis</code> otherwise.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; <em>order</em>type(:L, :R) :tran julia&gt; <em>order</em>type(:T, :R) :cis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._part1by1-Tuple{Int64}" href="#GraphLab._part1by1-Tuple{Int64}"><code>GraphLab._part1by1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_part1by1(n::Int)</code></pre><p>Expand 16-bit integer <code>n</code> into 32 bits with zeros between the original bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._partition-Tuple{Matrix, Vector}" href="#GraphLab._partition-Tuple{Matrix, Vector}"><code>GraphLab._partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_partition(coords::Matrix, v::Vector)</code></pre><p>Compute a partition based on <code>coords</code> using a direction vector <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix</code>: Node coordinates in a 2D space.</li><li><code>v::Vector</code>: Direction vector defining the partitioning line.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple of two vectors: indices of nodes in each partition.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _partition(coords, [0, 1])
([1, 2, 3, 9, 10], [4, 5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._partition-Tuple{Matrix{Float64}, Vector{Float64}}" href="#GraphLab._partition-Tuple{Matrix{Float64}, Vector{Float64}}"><code>GraphLab._partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_partition(X, direction)</code></pre><p>Splits a set of points into two parts by projecting them onto a given direction vector and _partitioning at the median projection value.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: An <code>n × d</code> matrix of points (each row is a point in ℝ^d or ℝ^{d+1}).</li><li><code>direction::Vector{Float64}</code>: A direction vector along which to project the points.</li></ul><p><strong>Returns</strong></p><ul><li><code>part1::Vector{Int}</code>: Indices of points with projection ≤ median (one side of the cut).</li><li><code>part2::Vector{Int}</code>: Indices of points with projection &gt; median (the other side).</li></ul><p><strong>Notes</strong></p><ul><li>This ensures a balanced _partition by cutting at the median of the projected values.</li><li>Commonly used to implement great-circle or hyperplane separators.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._recursive_bisection" href="#GraphLab._recursive_bisection"><code>GraphLab._recursive_bisection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_recursive_bisection(method::Function, levels::Int, A::AbstractSparseMatrix, 
                     coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8, 
                     vn::Vector{Int}=Int[])</code></pre><p>Recursively partition the graph <code>A</code> using the given partitioning <code>method</code>, applying hierarchical bisection.</p><p><strong>Arguments</strong></p><ul><li><code>method::Function</code>: Partitioning method to apply (e.g., <code>part_spectral</code>, <code>part_inertial</code>).</li><li><code>levels::Int</code>: Number of recursive partitioning levels.</li><li><code>A::AbstractSparseMatrix</code>: Adjacency matrix of the graph.</li><li><code>coords::Union{Matrix, Nothing}=nothing</code>: Node coordinates for spatial partitioning (if applicable).</li><li><code>minpoints::Int=8</code>: Minimum number of nodes required to continue partitioning.</li><li><code>vn::Vector{Int}=Int[]</code>: Vector of node indices, used for tracking original node ordering.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node, recursively refined through hierarchical bisection.</li></ul><p><strong>Example</strong></p><p><code>julia-repl julia&gt; _recursive_bisection(part_spectral, 3, A, coords)  1  ⋮  4</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._reflector-Tuple{Any}" href="#GraphLab._reflector-Tuple{Any}"><code>GraphLab._reflector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_reflector(c::AbstractVector)</code></pre><p>Constructs a Householder reflection matrix <code>Q</code> that maps the input vector <code>c</code> (reversed) to a multiple of the first basis vector. This is useful for aligning a given direction with a coordinate axis in geometric transformations.</p><p><strong>Arguments</strong></p><ul><li><code>c::AbstractVector</code>: A real vector of length <code>d</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Q::Matrix{Float64}</code>: A <code>d × d</code> orthogonal matrix representing the Householder reflection.</li><li><code>r::Float64</code>: The leading entry of the reflected vector (i.e., norm or signed component).</li></ul><p><strong>Notes</strong></p><ul><li>Internally, this performs a QR decomposition of the reversed vector <code>c[end:-1:1]</code> and adjusts the result to restore the original ordering.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._sepcircle-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}" href="#GraphLab._sepcircle-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}"><code>GraphLab._sepcircle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>_sepcircle(A::SparseMatrixCSC, X::Matrix{Float64}, ntrials::Int)</p><p>Try ntrials random great circle cuts on unit-sphere data.</p><p>Arguments:</p><ul><li>A::SparseMatrixCSC: adjacency matrix</li><li>X::Matrix{Float64}: n × (d+1) unit-sphere coordinates</li><li>ntrials::Int: number of random directions to try</li></ul><p>Returns:</p><ul><li>bestdir::Vector{Float64}: direction vector of best cut</li><li>mincut::Float64: minimum edge cut found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._sepline-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}" href="#GraphLab._sepline-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Int64}"><code>GraphLab._sepline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>_sepline(A, xy, ntrials)</p><p>Try ntrials random straight hyperplanes in Euclidean space.</p><p>Arguments:</p><ul><li>A::SparseMatrixCSC: adjacency matrix</li><li>coords::Matrix{Float64}: n × d original coordinates</li><li>ntrials::Int: number of directions to try</li></ul><p>Returns:</p><ul><li>bestdir::Vector{Float64}: best direction</li><li>mincut::Float64: corresponding edge cut</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._sepquality-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC, Matrix{Float64}}" href="#GraphLab._sepquality-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC, Matrix{Float64}}"><code>GraphLab._sepquality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_sepquality(v, A, xyz)</code></pre><p>Evaluates the quality of a geometric separator defined by a direction vector <code>v</code>, by computing the number of graph edges cut by the resulting _partition.</p><p><strong>Arguments</strong></p><ul><li><code>v::Vector{Float64}</code>: A direction vector defining the separating hyperplane (e.g., great circle).</li><li><code>A::SparseMatrixCSC</code>: The adjacency matrix of the (undirected) graph.</li><li><code>xyz::Matrix{Float64}</code>: An <code>n × (d+1)</code> matrix of vertex coordinates on the unit sphere (in ℝ^{d+1}).</li></ul><p><strong>Returns</strong></p><ul><li><code>cutsize::Int</code>: The number of edges crossing between the two sides of the _partition.</li></ul><p><strong>Notes</strong></p><ul><li>Vertices are _partitioned based on the sign of their projection onto <code>v</code>.</li><li>The number of crossing edges is computed using nonzero entries in <code>A[a, b]</code> and <code>A[b, a]&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._split-Tuple{Matrix{Float64}, Int64}" href="#GraphLab._split-Tuple{Matrix{Float64}, Int64}"><code>GraphLab._split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_split(coords::Matrix{Float64}, dim::Int)</code></pre><p>_split a set of 2D points along a specified dimension at the median.</p><p><strong>Arguments</strong></p><ul><li><code>coords::Matrix{Float64}</code>: A matrix of size <code>n × 2</code>, where each row is a 2D point <code>(x, y)</code>.</li><li><code>dim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li></ul><p><strong>Returns</strong></p><ul><li><code>left::Matrix{Float64}</code>: Points in the left subset (≤ _split value).</li><li><code>right::Matrix{Float64}</code>: Points in the right subset (&gt; _split value).</li><li><code>_splitval::Float64</code>: The coordinate value at which the _split occurs.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; left, right, _splitval = _split([1.0 2.0; 3.0 4.0; 0.0 5.0], 1) ([0.0 5.0; 1.0 2.0], [3.0 4.0], 1.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._step-Tuple{Symbol, Symbol, Int64, Tuple{Float64, Float64}, Float64}" href="#GraphLab._step-Tuple{Symbol, Symbol, Int64, Tuple{Float64, Float64}, Float64}"><code>GraphLab._step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_step(entry::Symbol, exit::Symbol, _splitdim::Int, entry_pt::Tuple{Float64, Float64}, _splitval::Float64)</code></pre><p>Determine the traversal order of child nodes in a kd-tree based on entry and exit directions.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Symbol</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>exit::Symbol</code>: Exit direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, or <code>:B</code>).</li><li><code>_splitdim::Int</code>: _splitting dimension (<code>1</code> for x-axis, <code>2</code> for y-axis).</li><li><code>entry_pt::Tuple{Float64, Float64}</code>: Coordinates of the entry point.</li><li><code>_splitval::Float64</code>: Value of the <em>splitting plane along `</em>splitdim`.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of symbols indicating the traversal order of child nodes (e.g., <code>[:left, :right]</code>).</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; _step(:L, :R, 1, (0.0, 0.5), 0.3) [:left, :right]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._stereodown-Tuple{Any}" href="#GraphLab._stereodown-Tuple{Any}"><code>GraphLab._stereodown</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_stereodown(xyz::AbstractMatrix)</code></pre><p>Performs the inverse of stereographic projection, mapping points from the unit sphere in ℝ^{d} (embedded in ℝ^{d+1}) back to Euclidean space ℝ^{d}.</p><p><strong>Arguments</strong></p><ul><li><code>xyz::AbstractMatrix</code>: An <code>n × (d + 1)</code> matrix where each row is a point on the unit sphere in ℝ^d.</li></ul><p><strong>Returns</strong></p><ul><li><code>xy::Matrix{Float64}</code>: An <code>n × d</code> matrix of projected points in Euclidean space.</li></ul><p><strong>Notes</strong></p><ul><li>Assumes the last coordinate in each row of <code>xyz</code> corresponds to the vertical axis (pole).</li><li>This operation is the inverse of the stereographic projection performed in <code>_stereoup</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._stereoup-Tuple{Matrix{Float64}}" href="#GraphLab._stereoup-Tuple{Matrix{Float64}}"><code>GraphLab._stereoup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Stereographically lift points to the unit sphere in (d+1)-dimensional space.</p><p>coords: n × d matrix of points Returns: n × (d+1) matrix on the unit sphere</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._traverse_kd" href="#GraphLab._traverse_kd"><code>GraphLab._traverse_kd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_traverse_kd(node::KdNode, entry::Symbol=:L, exit::Symbol=:R, last_exits::Vector{Any}=[], acc::Vector{Any}=[])</code></pre><p>Traverse a kd-tree following an adaptive space-filling curve and collect leaf data.</p><p>This function recursively traverses a kd-tree according to entry and exit directions, determining the order of child traversal at each node using adaptive rules. At each leaf node, it collects the stored data into an accumulator.</p><p><strong>Arguments</strong></p><ul><li><code>node::KdNode</code>: The kd-tree node to traverse.</li><li><code>entry::Symbol=:L</code>: Entry direction (<code>:L</code>, <code>:R</code>, <code>:T</code>, <code>:B</code>) at the current node.</li><li><code>exit::Symbol=:R</code>: Exit direction at the current node.</li><li><code>last_exits::Vector{Any}=[]</code>: List of exit points accumulated during traversal.</li><li><code>acc::Vector{Any}=[]</code>: Accumulator for collected leaf data.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>node.is_root</code>, returns <code>acc</code>, the accumulated leaf data in traversal order.</li><li>Otherwise returns the last exit point from the traversal.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; data = <em>traverse</em>kd(tree) [[x1, y1, id1], [x2, y2, id2], ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._vis_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}" href="#GraphLab._vis_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}"><code>GraphLab._vis_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_vis_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int})</code></pre><p>Visualize the partitioning <code>p</code> of graph <code>A</code> using node coordinates <code>coords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>coords</code>: Node coordinates for plotting.</li><li><code>p</code>: Partition labels for each node.</li></ul><p><strong>Output</strong></p><ul><li>Displays the partitioned graph visualization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab._vtxsep-NTuple{4, Any}" href="#GraphLab._vtxsep-NTuple{4, Any}"><code>GraphLab._vtxsep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_vtxsep(gborder, p1border, p2border, match)</code></pre><p>Computes a vertex separator based on alternating paths in a bipartite border graph.</p><p><strong>Arguments</strong></p><ul><li><code>gborder::Graph</code>: Bipartite graph between border nodes.</li><li><code>p1border::Vector{Int}</code>: Border nodes from partition 1.</li><li><code>p2border::Vector{Int}</code>: Border nodes from partition 2.</li><li><code>match</code>: Maximum matching result on <code>gborder</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>(sep, new_p1border, new_p2border)</code>: <ul><li><code>sep</code>: Separator set of vertices.</li><li><code>new_p1border</code>: Updated partition 1 border after separator removal.</li><li><code>new_p2border</code>: Updated partition 2 border after separator removal.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Traverses alternating paths between matching and non-matching edges to construct the separator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.build_adjacency-Tuple{Matrix{Int64}, Int64}" href="#GraphLab.build_adjacency-Tuple{Matrix{Int64}, Int64}"><code>GraphLab.build_adjacency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_adjacency(edges::Matrix{Int}, num_nodes::Int)</code></pre><p>Construct the adjacency matrix of a graph from an edge list.</p><p><strong>Arguments</strong></p><ul><li><code>edges::Matrix</code>: Matrix where each row represents an edge <code>[u, v]</code>.</li><li><code>num_nodes::Int</code>: Total number of nodes in the graph.</li></ul><p><strong>Returns</strong></p><ul><li>A symmetric sparse adjacency matrix (<code>SparseMatrixCSC{Int, Int}</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; edges = [1 2; 2 3; 3 1]
julia&gt; A = build_adjacency(edges, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.build_adjacency-Tuple{String}" href="#GraphLab.build_adjacency-Tuple{String}"><code>GraphLab.build_adjacency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_adjacency(type::String)</code></pre><p>Generate a predefined adjacency matrix and corresponding node coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>type::String</code>: Type of graph to generate.  <ul><li><code>&quot;network&quot;</code>: A predefined network structure.  </li><li><code>&quot;triangles&quot;</code>: A small triangular mesh structure.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>A::SparseMatrixCSC</code>: The sparse adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates for visualization.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A, coords = build_adjacency(&quot;network&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.compute_partition_balance-Tuple{AbstractVector}" href="#GraphLab.compute_partition_balance-Tuple{AbstractVector}"><code>GraphLab.compute_partition_balance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_partition_balance(p::AbstractVector) -&gt; Float64</code></pre><p>Computes the balance metric of a given graph partitioning.</p><p><strong>Parameters</strong></p><ul><li><code>p::AbstractVector</code>: A vector where <code>p[i]</code> represents the partition index assigned to vertex <code>i</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The balance metric, defined as the ratio of the largest partition size to the ideal partition size. A value close to <code>1.0</code> indicates a well-balanced partitioning, while higher values suggest imbalance.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; p = [1, 1, 2, 2, 2, 3, 3, 3, 3]  # Example partitioning julia&gt; balance = compute<em>partition</em>balance(p) julia&gt; println(balance)  # Output close to 1 for balanced partitions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.count_edge_cut-Tuple{AbstractMatrix, AbstractVector}" href="#GraphLab.count_edge_cut-Tuple{AbstractMatrix, AbstractVector}"><code>GraphLab.count_edge_cut</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">count_edge_cut(A::AbstractMatrix, p::AbstractVector)</code></pre><p>Count the number of edges that cross partitions in the graph <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>: Adjacency matrix of the graph.</li><li><code>p::AbstractVector</code>: Partition vector where <code>p[v]</code> represents the partition of vertex <code>v</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The number of edges that connect nodes in different partitions.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count_edge_cut(A, p)
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.draw_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}" href="#GraphLab.draw_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix, Vector{Int64}}"><code>GraphLab.draw_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int}; file_name::Union{String, Nothing}=nothing)</code></pre><p>Draw and optionally save a visualization of the partitioned graph <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>coords</code>: Node coordinates for plotting.</li><li><code>p</code>: Partition labels for each node.</li><li><code>file_name</code> (optional): If provided, saves the figure to the specified file.</li></ul><p><strong>Output</strong></p><ul><li>Returns the generated figure.</li><li>Saves the figure if <code>file_name</code> is specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.draw_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix}" href="#GraphLab.draw_graph-Tuple{SparseArrays.SparseMatrixCSC, Matrix}"><code>GraphLab.draw_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_graph(A::SparseMatrixCSC, coords::Matrix; file_name::Union{String, Nothing}=nothing)</code></pre><p>Draw and optionally save a visualization of the graph <code>A</code> without partitioning.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>coords</code>: Node coordinates for plotting.</li><li><code>file_name</code> (optional): If provided, saves the figure to the specified file.</li></ul><p><strong>Output</strong></p><ul><li>Returns the generated figure.</li><li>Saves the figure if <code>file_name</code> is specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.grid_graph-Tuple{Int64, Int64, Float64}" href="#GraphLab.grid_graph-Tuple{Int64, Int64, Float64}"><code>GraphLab.grid_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_graph(n::Int, m::Int, α::Float64)</code></pre><p>Returns the adjacency matrix <code>A::SparseMatrixCSC</code> and the coordinates <code>coords::Matrix{Float64}</code> of an <code>n × m</code> grid graph rotated by angle <code>α</code> (in radians).</p><p>Vertices are ordered row-wise: vertex <code>i,j</code> has index <code>(i-1)*m + j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}" href="#GraphLab.nested_dissection-Tuple{SparseArrays.SparseMatrixCSC, Function}"><code>GraphLab.nested_dissection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nested_dissection(A::SparseMatrixCSC, method::Function; coords=nothing, minsep=5, verbose=false)</code></pre><p>Computes a nested dissection ordering of the sparse matrix <code>A</code> using a given separator method.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: The sparse matrix.</li><li><code>method::Function</code>: Function to compute graph separators.</li><li><code>coords::Union{Matrix, Nothing}</code>: Optional node coordinates for geometric methods (default is <code>nothing</code>).</li><li><code>minsep::Int</code>: Minimum component size to stop recursion (default is 10).</li><li><code>verbose::Bool</code>: Whether to display visualizations and pause for input during recursion (default is <code>false</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>pA::Vector{Int}</code>: The computed permutation vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_adaptive_sfc" href="#GraphLab.part_adaptive_sfc"><code>GraphLab.part_adaptive_sfc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_adaptive_sfc(A::SparseMatrixCSC, coords::Matrix, k::Int=2)</code></pre><p>Partition a graph using an adaptive space-filling curve traversal.</p><p>This function builds a kd-tree from node coordinates, traverses the tree following an adaptive space-filling curve, and assigns partition labels based on traversal order. It returns a partition vector that assigns each node to one of <code>k</code> partitions.</p><p>This algorithm is based on &quot;A General Space-filling Curve Algorithm for Partitioning 2D Meshes&quot; (Aparna et al., 2015, DOI: 10.1109/HPCC-CSS-ICESS.2015.192) and &quot;Space-filling Curves for Partitioning Adaptively Refined Meshes&quot; (Sasidharan, Aparna, and Snir).</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: An <code>n × 2</code> matrix of node coordinates.</li><li><code>k::Int=2</code>: Number of partitions.</li></ul><p><strong>Returns</strong></p><ul><li>A vector <code>part</code> of length <code>n</code> assigning each node to a partition labeled <code>1</code> to <code>k</code>.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; part = part<em>adaptive</em>sfc(A, coords, 4) [1, 1, 2, 2, 3, 4, 4, ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_coordinate-Tuple{SparseArrays.SparseMatrixCSC, Matrix}" href="#GraphLab.part_coordinate-Tuple{SparseArrays.SparseMatrixCSC, Matrix}"><code>GraphLab.part_coordinate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_coordinate(A::SparseMatrixCSC, coords::Matrix)</code></pre><p>Compute a bi-partition of the graph <code>A</code> using the coordinate method based on <code>coords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates used for partitioning.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_coordinate(A, coords)
 1
 ⋮
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_geospectral-Tuple{SparseArrays.SparseMatrixCSC}" href="#GraphLab.part_geospectral-Tuple{SparseArrays.SparseMatrixCSC}"><code>GraphLab.part_geospectral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_geospectral(A::SparseMatrixCSC; ev::Int=2)</code></pre><p>Performs spectral partitioning by projecting the graph onto its low-frequency Laplacian eigenvectors, followed by geometric random sphere partitioning in the resulting embedding space.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: The adjacency matrix of an undirected graph.</li><li><code>ev::Int=2</code>: The number of Laplacian eigenvectors to use for embedding (default is 2).</li></ul><p><strong>Returns</strong></p><ul><li><code>p::Vector{Int}</code>: A partition of the vertex set, typically as cluster labels.</li></ul><p><strong>Notes</strong></p><ul><li>Emits a warning if the graph is large, as eigen decomposition may become computationally expensive.</li><li>This combines spectral embedding with geometric partitioning for improved structural fidelity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_inertial-Tuple{SparseArrays.SparseMatrixCSC, Matrix}" href="#GraphLab.part_inertial-Tuple{SparseArrays.SparseMatrixCSC, Matrix}"><code>GraphLab.part_inertial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_inertial(A::SparseMatrixCSC, coords::Matrix)</code></pre><p>Compute a bi-partition of the graph <code>A</code> using the inertial method based on <code>coords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates used for partitioning.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_inertial(A, coords)
 1
 ⋮
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_metis" href="#GraphLab.part_metis"><code>GraphLab.part_metis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_metis(A::SparseMatrixCSC, k::Int, alg::Symbol)</code></pre><p>Partition the graph <code>A</code> into <code>k</code> parts using METIS with the specified algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>k</code>: Number of partitions.</li><li><code>alg</code>: Partitioning algorithm (<code>:KWAY</code> or <code>:RECURSIVE</code>).</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of partition labels for each node.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_metis(A, 2, :RECURSIVE)
 1
 ⋮
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_randsphere-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}}" href="#GraphLab.part_randsphere-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}}"><code>GraphLab.part_randsphere</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>part_randsphere(A, coords; ntrials)</p><p>Geometric _partitioning using random spheres and lines.</p><p>Arguments:</p><ul><li>A::SparseMatrixCSC: adjacency matrix</li><li>coords::Matrix{Float64}: n × d node positions</li><li>ntries::Int (optional): number of directions to try (default: 30)</li></ul><p>Returns:</p><ul><li>part1, part2: vectors of node indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_sfc" href="#GraphLab.part_sfc"><code>GraphLab.part_sfc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_sfc(A::SparseMatrixCSC, coords::Matrix, k::Int=2, curve::Symbol=:gilbert)</code></pre><p>Partition the graph <code>A</code> into <code>k</code> parts using a space-filling curve on <code>coords</code>.</p><p>The coordinates are projected to a grid and ordered according to the selected space-filling curve (<code>:gilbert</code> or <code>:morton</code>). The resulting 1D ordering is then split into <code>k</code> contiguous segments.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates used for projection to grid.</li><li><code>k::Int</code>: Number of partitions (default = 2).</li><li><code>curve::Symbol</code>: Curve type, one of <code>:gilbert</code> or <code>:morton</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels (1 to <code>k</code>) for each node.</li></ul><p><strong>Example</strong></p><p>```julia-repl julia&gt; part_sfc(A, coords, 4, :morton)  1  ⋮  4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.part_spectral-Tuple{SparseArrays.SparseMatrixCSC}" href="#GraphLab.part_spectral-Tuple{SparseArrays.SparseMatrixCSC}"><code>GraphLab.part_spectral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_spectral(A::SparseMatrixCSC; fiedler::Bool=false)</code></pre><p>Compute a bi-partition of the graph <code>A</code> using the spectral method.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>fiedler::Bool=false</code>: If <code>true</code>, returns the Fiedler vector instead of partition labels.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels (1 or 2).</li><li>If <code>fiedler=true</code>, returns the Fiedler vector.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_spectral(A)
 1
 ⋮
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.recursive_bisection" href="#GraphLab.recursive_bisection"><code>GraphLab.recursive_bisection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">recursive_bisection(method::Function, k::Int, A::AbstractSparseMatrix, 
                    coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8)</code></pre><p>Partition the graph <code>A</code> into <code>k</code> parts using recursive bisection with the specified partitioning <code>method</code>.</p><p><strong>Arguments</strong></p><ul><li><code>method::Function</code>: Partitioning method to apply at each bisection step (e.g., <code>part_spectral</code>, <code>part_inertial</code>).</li><li><code>k::Int</code>: Number of partitions (must be a power of 2 or will be rounded up).</li><li><code>A::AbstractSparseMatrix</code>: Adjacency matrix of the graph.</li><li><code>coords::Union{Matrix, Nothing}=nothing</code>: Node coordinates for spatial partitioning (optional).</li><li><code>minpoints::Int=8</code>: Minimum number of nodes required for further partitioning.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; recursive_bisection(part_spectral, 4, A, coords)
 1
 ⋮
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphLab.wait_for_key-Tuple{Any}" href="#GraphLab.wait_for_key-Tuple{Any}"><code>GraphLab.wait_for_key</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wait_for_key(prompt)</code></pre><p>Prints a prompt to the standard output and waits for a single keypress from the user.</p><p><strong>Arguments</strong></p><ul><li><code>prompt::String</code>: The message to display before waiting for input.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphLab.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage Guide</a><a class="docs-footer-nextpage" href="../dev_api/">Developers API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 12 May 2025 22:17">Monday 12 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
