<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation ¬∑ GraphPartitioning.jl</title><meta name="title" content="Documentation ¬∑ GraphPartitioning.jl"/><meta property="og:title" content="Documentation ¬∑ GraphPartitioning.jl"/><meta property="twitter:title" content="Documentation ¬∑ GraphPartitioning.jl"/><meta name="description" content="Documentation for GraphPartitioning.jl."/><meta property="og:description" content="Documentation for GraphPartitioning.jl."/><meta property="twitter:description" content="Documentation for GraphPartitioning.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="GraphPartitioning.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">GraphPartitioning.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="documentation.html">Documentation</a><ul class="internal"><li><a class="tocitem" href="#Graph-Construction"><span>Graph Construction</span></a></li><li><a class="tocitem" href="#Native-Partitioning-Methods"><span>Native Partitioning Methods</span></a></li><li><a class="tocitem" href="#Recursive-Bisection"><span>Recursive Bisection</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Utility-Function"><span>Utility Function</span></a></li><li><a class="tocitem" href="#Interfacing-with-External-Partitioning-Tools"><span>Interfacing with External Partitioning Tools</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="documentation.html">Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="documentation.html">Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lechekhabm/GraphPartitioning.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><h2 id="Graph-Construction"><a class="docs-heading-anchor" href="#Graph-Construction">Graph Construction</a><a id="Graph-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Construction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.build_adjacency" href="#GraphPartitioning.build_adjacency"><code>GraphPartitioning.build_adjacency</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_adjacency(edges::Matrix{Int}, num_nodes::Int)</code></pre><p>Construct the adjacency matrix of a graph from an edge list.</p><p><strong>Arguments</strong></p><ul><li><code>edges::Matrix</code>: Matrix where each row represents an edge <code>[u, v]</code>.</li><li><code>num_nodes::Int</code>: Total number of nodes in the graph.</li></ul><p><strong>Returns</strong></p><ul><li>A symmetric sparse adjacency matrix (<code>SparseMatrixCSC{Int, Int}</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; edges = [1 2; 2 3; 3 1]
julia&gt; A = build_adjacency(edges, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section><section><div><pre><code class="language-julia hljs">build_adjacency(type::String)</code></pre><p>Generate a predefined adjacency matrix and corresponding node coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>type::String</code>: Type of graph to generate.  <ul><li><code>&quot;network&quot;</code>: A predefined network structure.  </li><li><code>&quot;triangles&quot;</code>: A small triangular mesh structure.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>A::SparseMatrixCSC</code>: The sparse adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates for visualization.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A, coords = build_adjacency(&quot;network&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><h2 id="Native-Partitioning-Methods"><a class="docs-heading-anchor" href="#Native-Partitioning-Methods">Native Partitioning Methods</a><a id="Native-Partitioning-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Native-Partitioning-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.part_coordinate" href="#GraphPartitioning.part_coordinate"><code>GraphPartitioning.part_coordinate</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_coordinate(A::SparseMatrixCSC, coords::Matrix)</code></pre><p>Compute a bi-partition of the graph <code>A</code> using the coordinate method based on <code>coords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates used for partitioning.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_coordinate(A, coords)
 1
 ‚ãÆ
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.part_inertial" href="#GraphPartitioning.part_inertial"><code>GraphPartitioning.part_inertial</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_inertial(A::SparseMatrixCSC, coords::Matrix)</code></pre><p>Compute a bi-partition of the graph <code>A</code> using the inertial method based on <code>coords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>coords::Matrix</code>: Node coordinates used for partitioning.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_inertial(A, coords)
 1
 ‚ãÆ
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.part_spectral" href="#GraphPartitioning.part_spectral"><code>GraphPartitioning.part_spectral</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_spectral(A::SparseMatrixCSC; fiedler::Bool=false)</code></pre><p>Compute a bi-partition of the graph <code>A</code> using the spectral method.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseMatrixCSC</code>: Adjacency matrix of the graph.</li><li><code>fiedler::Bool=false</code>: If <code>true</code>, returns the Fiedler vector instead of partition labels.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels (1 or 2).</li><li>If <code>fiedler=true</code>, returns the Fiedler vector.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_spectral(A)
 1
 ‚ãÆ
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.part_metis" href="#GraphPartitioning.part_metis"><code>GraphPartitioning.part_metis</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">part_metis(A::SparseMatrixCSC, k::Int, alg::Symbol)</code></pre><p>Partition the graph <code>A</code> into <code>k</code> parts using METIS with the specified algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>k</code>: Number of partitions.</li><li><code>alg</code>: Partitioning algorithm (<code>:KWAY</code> or <code>:RECURSIVE</code>).</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of partition labels for each node.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; part_metis(A, 2, :RECURSIVE)
 1
 ‚ãÆ
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><h2 id="Recursive-Bisection"><a class="docs-heading-anchor" href="#Recursive-Bisection">Recursive Bisection</a><a id="Recursive-Bisection-1"></a><a class="docs-heading-anchor-permalink" href="#Recursive-Bisection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.recursive_bisection" href="#GraphPartitioning.recursive_bisection"><code>GraphPartitioning.recursive_bisection</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">recursive_bisection(method::Function, k::Int, A::AbstractSparseMatrix, 
                    coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8)</code></pre><p>Partition the graph <code>A</code> into <code>k</code> parts using recursive bisection with the specified partitioning <code>method</code>.</p><p><strong>Arguments</strong></p><ul><li><code>method::Function</code>: Partitioning method to apply at each bisection step (e.g., <code>part_spectral</code>, <code>part_inertial</code>).</li><li><code>k::Int</code>: Number of partitions (must be a power of 2 or will be rounded up).</li><li><code>A::AbstractSparseMatrix</code>: Adjacency matrix of the graph.</li><li><code>coords::Union{Matrix, Nothing}=nothing</code>: Node coordinates for spatial partitioning (optional).</li><li><code>minpoints::Int=8</code>: Minimum number of nodes required for further partitioning.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of partition labels for each node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; recursive_bisection(part_spectral, 4, A, coords)
 1
 ‚ãÆ
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.draw_graph" href="#GraphPartitioning.draw_graph"><code>GraphPartitioning.draw_graph</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int}; file_name::Union{String, Nothing}=nothing)</code></pre><p>Draw and optionally save a visualization of the partitioned graph <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>coords</code>: Node coordinates for plotting.</li><li><code>p</code>: Partition labels for each node.</li><li><code>file_name</code> (optional): If provided, saves the figure to the specified file.</li></ul><p><strong>Output</strong></p><ul><li>Returns the generated figure.</li><li>Saves the figure if <code>file_name</code> is specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section><section><div><pre><code class="language-julia hljs">draw_graph(A::SparseMatrixCSC, coords::Matrix; file_name::Union{String, Nothing}=nothing)</code></pre><p>Draw and optionally save a visualization of the graph <code>A</code> without partitioning.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Adjacency matrix of the graph.</li><li><code>coords</code>: Node coordinates for plotting.</li><li><code>file_name</code> (optional): If provided, saves the figure to the specified file.</li></ul><p><strong>Output</strong></p><ul><li>Returns the generated figure.</li><li>Saves the figure if <code>file_name</code> is specified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><h2 id="Utility-Function"><a class="docs-heading-anchor" href="#Utility-Function">Utility Function</a><a id="Utility-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPartitioning.count_edge_cut" href="#GraphPartitioning.count_edge_cut"><code>GraphPartitioning.count_edge_cut</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">count_edge_cut(A::AbstractMatrix, p::AbstractVector)</code></pre><p>Count the number of edges that cross partitions in the graph <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>: Adjacency matrix of the graph.</li><li><code>p::AbstractVector</code>: Partition vector where <code>p[v]</code> represents the partition of vertex <code>v</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The number of edges that connect nodes in different partitions.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count_edge_cut(A, p)
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lechekhabm/GraphPartitioning.jl">source</a></section></article><h2 id="Interfacing-with-External-Partitioning-Tools"><a class="docs-heading-anchor" href="#Interfacing-with-External-Partitioning-Tools">Interfacing with External Partitioning Tools</a><a id="Interfacing-with-External-Partitioning-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-with-External-Partitioning-Tools" title="Permalink"></a></h2><p>To integrate with graph partitioning tools such as KaHIP, Graclus, and MDC, we provide utility functions for exporting graph structures, executing external commands, and managing dependencies. These functions streamline the workflow, ensuring compatibility with external software while maintaining interoperability with <code>GraphPartitioning.jl</code>.</p><h3 id="Writing-a-Graph-File-for-Partitioning-Tools"><a class="docs-heading-anchor" href="#Writing-a-Graph-File-for-Partitioning-Tools">Writing a Graph File for Partitioning Tools</a><a id="Writing-a-Graph-File-for-Partitioning-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-a-Graph-File-for-Partitioning-Tools" title="Permalink"></a></h3><p>This function generates a graph file compatible with tools like KaHIP, Graclus, and MDC from a symmetric adjacency matrix. <strong>Steps:</strong>     1. Extract the number of nodes and edges from the adjacency matrix.     2. Create a temporary file or save it to ./adjacency_lists depending on the temp flag.     3. Write the graph format:         - The first line contains the number of nodes and edges.         - Each subsequent line lists the neighbors of a node.</p><p><strong>Usage:</strong>     - If temp=true, the file is temporary.     - If temp=false, the file is saved in ./adjacency_lists with a specified prefix.</p><pre><code class="language-julia hljs">function _write_partition_input(A::SparseMatrixCSC; prefix::String=&quot;graph&quot;, temp::Bool=false)
    n_nodes = size(A, 1)
    I, J, _ = findnz(A)
    n_edges = div(length(I), 2)

    if temp
        mktemp() do file, _
            write(file, &quot;$n_nodes $n_edges\n&quot;)

            for i in 1:n_nodes  
                neighbors = J[findall(==(i), I)]
                write(file, join(neighbors, &quot; &quot;) * &quot;\n&quot;)
            end

            return file
        end
    else
        dir = &quot;./adjacency_lists&quot;
        mkpath(dir)
        file_path = joinpath(dir, &quot;$prefix.graph&quot;)

        open(file_path, &quot;w&quot;) do file
            write(file, &quot;$n_nodes $n_edges\n&quot;)
            for i in 1:n_nodes
                neighbors = J[findall(==(i), I)]
                write(file, join(neighbors, &quot; &quot;) * &quot;\n&quot;)
            end
        end

        return file_path
    end
end</code></pre><h3 id="Running-an-External-Command-and-Capturing-Output"><a class="docs-heading-anchor" href="#Running-an-External-Command-and-Capturing-Output">Running an External Command and Capturing Output</a><a id="Running-an-External-Command-and-Capturing-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Running-an-External-Command-and-Capturing-Output" title="Permalink"></a></h3><p>This function runs a shell command and captures both stdout and stderr. <strong>Steps:</strong></p><pre><code class="nohighlight hljs">1. Execute the command asynchronously.
2. Capture stdout and stderr into separate tasks.
3. Wait for the process to finish and return the outputs.</code></pre><pre><code class="language-julia hljs">function _run_cmd(cmd::Cmd)
	out = Pipe()
	err = Pipe()

	process = run(pipeline(cmd, stdout=out, stderr=err), wait=false)

	close(out.in)
	close(err.in)

	stdout_task = @async String(read(out))
	stderr_task = @async String(read(err))

	wait(process)

	return (
		stdout = fetch(stdout_task),
		stderr = fetch(stderr_task),
		code = process.exitcode
	)
end</code></pre><h3 id="Retrieving-and-Validating-an-Executable-Path"><a class="docs-heading-anchor" href="#Retrieving-and-Validating-an-Executable-Path">Retrieving and Validating an Executable Path</a><a id="Retrieving-and-Validating-an-Executable-Path-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-and-Validating-an-Executable-Path" title="Permalink"></a></h3><p>This function retrieves an external executable&#39;s path from an environment variable and ensures it exists. <strong>Steps:</strong></p><pre><code class="nohighlight hljs">1. Check if the environment variable is set.
2. Retrieve the executable path.
3. Verify that the file exists; otherwise, throw an error.</code></pre><pre><code class="language-julia hljs">function _get_executable(exec_name::String)
    if !haskey(ENV, exec_name)
        error(&quot;‚ùå Environment variable $exec_name is not set. Please define it with the path to the executable.&quot;)
    end

    exec_path = ENV[exec_name]

    # Check if the file exists
    if !isfile(exec_path)
        error(&quot;‚ùå Executable &#39;$exec_path&#39; not found. Please check the $exec_name environment variable.&quot;)
    end

    return exec_path
end</code></pre><hr/><p>With these core utility functions in place, we can now implement functions tailored to specific partitioning software.</p><h3 id="Graclus"><a class="docs-heading-anchor" href="#Graclus">Graclus</a><a id="Graclus-1"></a><a class="docs-heading-anchor-permalink" href="#Graclus" title="Permalink"></a></h3><p>Graclus is a spectral-based graph clustering and partitioning software.  </p><ul><li><strong>Installation</strong>: You need to manually <strong>download and compile Graclus</strong> from its <a href="https://www.cs.utexas.edu/~dml/Software/graclus.html">official source</a>.  </li><li><strong>Environment Variable</strong>: Set <code>GRACLUS_PATH</code> to point to the compiled Graclus executable.  </li></ul><pre><code class="language-bash hljs">export GRACLUS_PATH=&quot;/path/to/graclus&quot;</code></pre><pre><code class="language-julia hljs">function run_graclus(A::SparseMatrixCSC, np::Int; cut_type::String=&quot;ncut&quot;, local_search::Int=0, dbg::Bool=false)

    mat_path = _write_partition_input(A)

    graclus_exec = _get_executable(&quot;GRACLUS_PATH&quot;)

	cmd = `$graclus_exec $mat_path $np -O $cut_type -L $local_search`;

    result = _run_cmd(cmd)
	
    if result.code != 0
        error(&quot;‚ùå Graclus execution failed with error:\n&quot; * result.code)
    end

    partition_file = &quot;graph.graph&quot;*&quot;.part.&quot;*string(np)
    partitions = Int[]

    try
        open(partition_file, &quot;r&quot;) do f
            for line in eachline(f)
                push!(partitions, parse(Int, line))
            end
        end
        println(&quot;‚úÖ Partitions extracted from &quot;, partition_file)
    catch e
        error(&quot;‚ùå Failed to read partition file &#39;$partition_file&#39;: &quot;, e)
    end

    if dbg
        println(&quot;üñ•Ô∏è Execution Result:\n&quot;, result.stdout)
        println(&quot;üìÇ Partition File: &quot;, partition_file)
        println(&quot;üî¢ Partitions: &quot;, partitions)
        return partitions
    else
        # Remove the partition file after reading
        rm(partition_file, force=true)
        return partitions
    end
end</code></pre><h4 id="Citation"><a class="docs-heading-anchor" href="#Citation">Citation</a><a id="Citation-1"></a><a class="docs-heading-anchor-permalink" href="#Citation" title="Permalink"></a></h4><ul><li>Weighted Graph Cuts without Eigenvectors: A Multilevel Approach, I. Dhillon, Y. Guan, and B, Kulis, IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), vol. 29:11, pages 1944-1957, November 2007.</li><li>A Fast Kernel-based Multilevel Algorithm for Graph Clustering, I. Dhillon, Y. Guan, and B, Kulis, Proceedings of The 11th ACM SIGKDD, Chicago, IL, August 21-24, 2005.</li><li>Kernel k-means, Spectral Clustering and Normalized Cuts, I. Dhillon, Y. Guan, and B. Kulis, Proceedings of The 10th ACM SIGKDD, Seattle, WA, August 22-25, 2004.</li></ul><hr/><h3 id="KaHIP-(run_kahip)"><a class="docs-heading-anchor" href="#KaHIP-(run_kahip)">KaHIP <code>(run_kahip)</code></a><a id="KaHIP-(run_kahip)-1"></a><a class="docs-heading-anchor-permalink" href="#KaHIP-(run_kahip)" title="Permalink"></a></h3><p>KaHIP (Karlsruhe High-Quality Partitioning) is an efficient graph partitioning tool that supports various heuristics and optimizations.</p><ul><li><strong>Installation</strong>: You need to <strong>download and compile KaHIP</strong> from its <a href="https://kahip.github.io/">official source</a>.</li><li><strong>Environment Variable</strong>: Set <code>KAHIP_PATH</code> to the KaHIP binary.</li></ul><pre><code class="language-bash hljs">export KAHIP_PATH=&quot;/path/to/kahip&quot;</code></pre><pre><code class="language-julia hljs">function run_kahip(A::SparseMatrixCSC, np::Int; preconfiguration::String=&quot;fast&quot;, dbg::Bool=false)

    mat_path = _write_partition_input(A)

    kahip_exec = _get_executable(&quot;KAHIP_PATH&quot;)

	cmd = `$kahip_exec $mat_path --k $np --preconfiguration=$preconfiguration`;

    result = _run_cmd(cmd)
	
    if result.code != 0
        error(&quot;KaHIP execution failed with error:\n&quot; * result.code)
    end

    partition_file = &quot;tmppartition&quot; * string(np)
    partitions = Int[]

    try
        open(partition_file, &quot;r&quot;) do f
            for line in eachline(f)
                push!(partitions, parse(Int, line))
            end
        end
        println(&quot;‚úÖ Partitions extracted from &quot;, partition_file)
    catch e
        error(&quot;‚ùå Failed to read partition file &#39;$partition_file&#39;: &quot;, e)
    end

    if dbg
        println(&quot;üñ•Ô∏è Execution Result:\n&quot;, result.stdout)
        println(&quot;üìÇ Partition File: &quot;, partition_file)
        println(&quot;üî¢ Partitions: &quot;, partitions)
        return partitions
    else
        # Remove the partition file after reading
        rm(partition_file, force=true)
        return partitions
    end
end</code></pre><h4 id="Citation-2"><a class="docs-heading-anchor" href="#Citation-2">Citation</a><a class="docs-heading-anchor-permalink" href="#Citation-2" title="Permalink"></a></h4><ul><li>Peter Sanders and Christian Schulz. Engineering Multilevel Graph Partitioning Algorithms. In Proceedings of the 19th European Symposium on Algorithms (ESA&#39;11), volume 6942 of LNCS, pages 469‚Äì480. Springer, 2011.</li></ul><hr/><h3 id="Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)"><a class="docs-heading-anchor" href="#Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)">Multi-Level Diffusion Clustering (MDC) <code>(run_mdc)</code></a><a id="Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)" title="Permalink"></a></h3><p>MDC is an experimental diffusion-based graph partitioning method.</p><ul><li><strong>Installation</strong>: You must <strong>download, compile, and install MDC</strong> following the instructions from <a href="https://kahip.github.io/">official source</a>.</li><li><strong>Environment Variable</strong>: Set <code>MDC_PATH</code> to point to the MDC executable. It also requires setting <code>LD_LIBRARY_PATH</code> for proper execution.</li></ul><pre><code class="language-bash hljs">export MDC_PATH=&quot;/path/to/mdc&quot;
export LD_LIBRARY_PATH=&quot;/path/to/stag/stag-1.3.0/build_dir/stag_lib/&quot;</code></pre><pre><code class="language-julia hljs">function run_mdc(A::SparseMatrixCSC,
                np::Int;
                cut_type::String=&quot;ncut&quot;,
                local_search::Int=0,
                beta_testing::Bool=true,
                spectral_method::Bool=true,
                beta_min::Int=0,
                beta_max::Int=2,
                dbg::Bool=false)

    mat_path = _write_partition_input(A)

    mdc_exec = _get_executable(&quot;MDC_PATH&quot;)

	cmd = `$mdc_exec $mat_path $np -b $beta_testing -s $spectral_method -O $cut_type -y $beta_min -z $beta_max -L $local_search`;

    result = _run_cmd(cmd)
	
    if result.code != 0
        error(&quot;‚ùå MDC execution failed with error:\n&quot; * result.code)
    end

    partition_file = &quot;graph.graph&quot;*&quot;.part.&quot;*string(np)
    partitions = Int[]

    try
        open(partition_file, &quot;r&quot;) do f
            for line in eachline(f)
                push!(partitions, parse(Int, line))
            end
        end
        println(&quot;‚úÖ Partitions extracted from &quot;, partition_file)
    catch e
        error(&quot;‚ùå Failed to read partition file &#39;$partition_file&#39;: &quot;, e)
    end

    if dbg
        println(&quot;üñ•Ô∏è Execution Result:\n&quot;, result.stdout)
        println(&quot;üìÇ Partition File: &quot;, partition_file)
        println(&quot;üî¢ Partitions: &quot;, partitions)
        return partitions
    else
        # Remove the partition file after reading
        rm(partition_file, force=true)
        return partitions
    end
end</code></pre><h4 id="Citation-3"><a class="docs-heading-anchor" href="#Citation-3">Citation</a><a class="docs-heading-anchor-permalink" href="#Citation-3" title="Permalink"></a></h4><ul><li>Lechekhab M., Pasadakis D., Schenk O. (forthcoming) Multilevel Diffusion Based Spectral Graph Clustering. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. IEEE. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. Virtual Conference. September 23-27, 2024</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">¬´ Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 6 March 2025 14:52">Thursday 6 March 2025</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
